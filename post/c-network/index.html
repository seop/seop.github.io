<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TCP 서버/클라이언트 프로그래밍 | io.github.seop</title><meta name=keywords content="c,tcp,network,server,client"><meta name=description content="클라이언트 프로그램 클라이언트 프로그램은 1. 소켓 생성, 2. 서버의 인터넷 주소 설정, 3. 연결 요청, 4. 통신(읽기/쓰기), 5. 연결 종료 순서로 진행된다.
소켓 생성 #include <sys/types.h> #include <sys/socket.h> int main() { ... int ssock; if((ssock # socket(PF_INET, SOCK_STREAN, IPPROTO_TCP)) < 0) { perror(&#34;socket error : &#34;); exit(1); } ... } 소켓을 생성한다. socket이라는 함수에 인자값을 주어 소켓 생성에 성공하면, 0보다 큰값의 디스크립션을 반환한다. 보통 3 이상의 값이 반환된다. 0은 표준입력, 1은 표준출력, 2는 표준에러로 예약되어 있다."><meta name=author content><link rel=canonical href=https://seop.github.io/post/c-network/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://seop.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://seop.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://seop.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://seop.github.io/apple-touch-icon.png><link rel=mask-icon href=https://seop.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="TCP 서버/클라이언트 프로그래밍"><meta property="og:description" content="클라이언트 프로그램 클라이언트 프로그램은 1. 소켓 생성, 2. 서버의 인터넷 주소 설정, 3. 연결 요청, 4. 통신(읽기/쓰기), 5. 연결 종료 순서로 진행된다.
소켓 생성 #include <sys/types.h> #include <sys/socket.h> int main() { ... int ssock; if((ssock # socket(PF_INET, SOCK_STREAN, IPPROTO_TCP)) < 0) { perror(&#34;socket error : &#34;); exit(1); } ... } 소켓을 생성한다. socket이라는 함수에 인자값을 주어 소켓 생성에 성공하면, 0보다 큰값의 디스크립션을 반환한다. 보통 3 이상의 값이 반환된다. 0은 표준입력, 1은 표준출력, 2는 표준에러로 예약되어 있다."><meta property="og:type" content="article"><meta property="og:url" content="https://seop.github.io/post/c-network/"><meta property="article:section" content="post"><meta property="article:published_time" content="2012-02-01T09:00:00+09:00"><meta property="article:modified_time" content="2012-02-01T09:00:00+09:00"><meta property="og:site_name" content="io.github.seop"><meta name=twitter:card content="summary"><meta name=twitter:title content="TCP 서버/클라이언트 프로그래밍"><meta name=twitter:description content="클라이언트 프로그램 클라이언트 프로그램은 1. 소켓 생성, 2. 서버의 인터넷 주소 설정, 3. 연결 요청, 4. 통신(읽기/쓰기), 5. 연결 종료 순서로 진행된다.
소켓 생성 #include <sys/types.h> #include <sys/socket.h> int main() { ... int ssock; if((ssock # socket(PF_INET, SOCK_STREAN, IPPROTO_TCP)) < 0) { perror(&#34;socket error : &#34;); exit(1); } ... } 소켓을 생성한다. socket이라는 함수에 인자값을 주어 소켓 생성에 성공하면, 0보다 큰값의 디스크립션을 반환한다. 보통 3 이상의 값이 반환된다. 0은 표준입력, 1은 표준출력, 2는 표준에러로 예약되어 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://seop.github.io/post/"},{"@type":"ListItem","position":3,"name":"TCP 서버/클라이언트 프로그래밍","item":"https://seop.github.io/post/c-network/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TCP 서버/클라이언트 프로그래밍","name":"TCP 서버\/클라이언트 프로그래밍","description":"클라이언트 프로그램 클라이언트 프로그램은 1. 소켓 생성, 2. 서버의 인터넷 주소 설정, 3. 연결 요청, 4. 통신(읽기/쓰기), 5. 연결 종료 순서로 진행된다.\n소켓 생성 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int main() { ... int ssock; if((ssock # socket(PF_INET, SOCK_STREAN, IPPROTO_TCP)) \u0026lt; 0) { perror(\u0026#34;socket error : \u0026#34;); exit(1); } ... } 소켓을 생성한다. socket이라는 함수에 인자값을 주어 소켓 생성에 성공하면, 0보다 큰값의 디스크립션을 반환한다. 보통 3 이상의 값이 반환된다. 0은 표준입력, 1은 표준출력, 2는 표준에러로 예약되어 있다.","keywords":["c","tcp","network","server","client"],"articleBody":"클라이언트 프로그램 클라이언트 프로그램은 1. 소켓 생성, 2. 서버의 인터넷 주소 설정, 3. 연결 요청, 4. 통신(읽기/쓰기), 5. 연결 종료 순서로 진행된다.\n소켓 생성 #include #include int main() { ... int ssock; if((ssock # socket(PF_INET, SOCK_STREAN, IPPROTO_TCP)) \u003c 0) { perror(\"socket error : \"); exit(1); } ... } 소켓을 생성한다. socket이라는 함수에 인자값을 주어 소켓 생성에 성공하면, 0보다 큰값의 디스크립션을 반환한다. 보통 3 이상의 값이 반환된다. 0은 표준입력, 1은 표준출력, 2는 표준에러로 예약되어 있다. 소켓 생성에 실패하면 음수값의 디스크립션을 반환한다. socket 함수 소켓 지정자 socket(인자 도메인, 소켓의 형태, 프로토콜의 종류) 해당 소켓을 생성하고 소켓의 디스크립션을 반환한다. 즉, 인자 값을 받아 소켓을 생성한 후에 해당 소켓의 지정자를 반환한다. #include #include int socket(int domain, int type, int protocol) 인자 도메인 (domain) 네트워크의 종류를 나타낸다. (노벨IPX, ATM, X.25, IPv6, TCP/IP 등) 네트워크의 종류에 따라 프로토콜이 다르게 구성되어 있으며, 리눅스에서는 도메인이라는 개념을 사용해 구분한다. TCP/IP는 PF_INET 프로토콜 패밀리에 정의되어 있다. PF_INET은 주소값이다. IP주소를 사용한다. 프로토콜 패밀리는 에서 정의한다. 로컬 소켓을 사용해 소켓을 내부 프로세스가 통신하는 용도로 사용하려면 PF_UNIX나 PF_LOCAL를 사용한다. 내부 프로세스 통신을 위해 사용할 때는 데이터 전송을 위한 파일 경로가 들어가게 된다. 프로토콜 패밀리 설명 PF_UNIX 유닉스 도메인 소켓 PF_LOCAL PF_UNIX 소켓의 포직스 표현 PF_INET 인터넷 프로토콜(TCP/IP) PF_IPX 노벨 IPX PF_AX25 아마추어 라디오 AX.25 PF_APPLETALK 애플토크 DDP PF_INET6 IPv6 프로토콜 PF_ROSE 아마추어 라디오 X.25 PLP PF_X25 X.25 프로젝트를 위해 예약 PF_IRDA 적외선(IrDA) 소켓 PF_NETBEUI 802.2LLC 프로젝트를 위해 예약 PF_LLC 리눅스 LLC PF_BLUETOOTH 블루투스 소켓 소켓의 형태 (type) 소켓의 형태는 소켓의 연결 형식을 정의한다. PF_INET에서 주로 사용하는 소켓 연결 형식에는 SOCK_STREAM, SOCK_DGRAM, SOCK_RAW가 있다. SOCK_STREAM : TCP를 통해 전송되는 신뢰성 있는 연결 SOCK_DGRAM : UDP를 통해 전송되는 신뢰성 없는 연결. SOCK_RAW : 헤더를 직접 만들어서 사용해야 하는 연결 형식. SOCK_STREAM, SOCK_DGRAM의 헤더는 운영체제에서 자동으로 만들어준다. 프로토콜의 종류 (protocol) 소켓에서 사용될 프로토콜을 지정한다. 프로토콜 설명 0 도메인과 소켓의 형태에 따른 기본 프로토콜이 자동 결정된다 IPPROTO_IP IPPROTO_TCP TCP 프로토콜 사용 IPPROTO_UDP UDP 프로토콜 사용 IPPROTO_RAW IPPROTO_ICMP IPPROTO_ICMPV6 서버의 인터넷 주소 설정 ... struct sockaddr_in server_addr; memset(\u0026server_addr, 0, sizeof(server_addr)); server_addr.sin_family # AF_INET; /* # PF_INET */ server_addr.sin_addr.s_addr # inet_addr(\"127.0.0.1\"); server_addr.sin_port # htons(2217); ... 접속할 서버의 주소를 설정한다. 프로토콜 패밀리와 IP 주소, Port 주소를 각각 정해준다. 네트워크 바이트 오더를 적용해야 하기 때문에 IP 주소와 Port 주소는 inet_addr(), htons() 함수를 통해서 값을 넣어주어야 한다. sockaddr_in 구조체는 INET 인터넷 프로토콜의 TCP 헤더를 구성한다. typedef unsigned short sa_family_t; struct in_addr { __u32 s_addr; }; #define __SOCK_SIZE__ 16 struct sockaddr_in { sa_family_t sin_family; /*주소패밀리*/ unsigned short int sin_port; /*포트번호*/ struct in_addr sin_addr; /*IP주소*/ unsigned char __pad[__SOCK_SIZE - sizeof(short int) - sizeof(unsigned short int) - sizeof(struct in_addr)]; /* Pad to size of 'struct sockaddr' */ }; inet_addr 함수 이진 바이너리 형식의 IP 주소 inet_addr(문자 형식의 IP 주소) 문자 형식의 IP 주소를 네트워크 바이트 오더를 적용한 이진 바이너리 코드로 바꾸어 변환한다. 리틀 엔디안(Little Endian)과 빅 엔디안(Big Endian) 이라는 바이트 오더의 개념을 알아야 한다. 네트워크 프로토콜 표준에서 사용하는 바이트 오더는 빅 엔디안이다. x86 호환 아키텍처에서는 리틀 엔디안을 사용한다. #include #include #include unsigned long int inet_addr(const char *cp) htons 함수 네트워크 바이트 오더가 적용된 이진 바이너리 16비트 값 htons (16비트 변수 값) 16비트의 unsigned short형 숫자 값에 네트워크 바이트 오더를 적용한 후 반환한다. #include uint16_t htons(uint16_t hostshort) 연결 요청 ... clen # sizeof(server_addr); if(connect(ssock, (struct sockaddr *)\u0026server_addr, clen) \u003c 0) { peror(\"connect error :\"); exit(1); } 소켓 생성이 완료되면 생성된 소켓을 이용하여 서버에 연결해야 한다. 이때 connect() 함수를 사용한다. connect 함수 리턴 값 connect(소켓 디스크립션, 서버의 IP 주소와 포트번호, 길이) 소켓 연결을 시작한다. 생성된 소켓과 서버의 정보를 이용해서 해당 서버에 연결한 후 결과값을 리턴한다. 1이면 성공, -1이면 실패를 의미한다. #include #include int connect(int sockfd, const struct sockaddr *serv_addr, soclen_t addrlen); 통신(읽기/쓰기) memset(buf, 0, MAXBUF); if(read(ssock, buf, MAXBUF) \u003c# 0) { perror(\"read error :\"); exit(1); } 서버에서 데이터를 읽어오려면 read() 함수를 사용한다. 데이터를 수신한 후 buf에 저장한다. read 함수 읽은 값의 길이 read(파일 디스크립터, 읽은 데이터를 저장할 버퍼, 읽을 데이터 최대 길이) 지정된 파일 디스크립터에서 데이터를 읽어서 지정된 버퍼에 데이터를 넣은 후 읽은 데이터의 길이를 반환한다. 오류가 발생하면 -1을 반환한다. 네트워크 프로그래밍에서 파일 디스크립터에 해당하는 것이 소켓 디스크립터이다. #include ssize_t read(int fd, void *buf, size_t count) 연결 종료 close(ssock); close 함수 성공 여부 반환 close(파일 디스크립터) close 함수는 파일 디스크립터를 닫는다. 닫힌 파일 디스크립터는 더 이상 참조되거나 사용될 수 없다. 닫기에 성공하면 0을 반환하고 오류가 발생하면 -1을 반환한다. #include int close(int fd) 서버 프로그램 서버 프로그램은 1. 소켓 생성, 2. 인터넷 주소 부여, 3. 연결 수신 대기, 4. 연결 수신, 5. 통신(읽기/쓰기), 6. 연결 수신 대기(이후 과정 반복) 순서로 진행된다.\n소켓 생성 클라이언트 프로그램 부분과 같다.\n인터넷 주소 부여 ... server_addr.sin_family # AF_INET; server_addr.sin_addr.s_addr # htonl(INADDR_ANY); server_addr.sin_port # htons(2999); if(bind(ssock, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) \u003c 0 { perror(\"bind error : \"); exit(1); } server_addr.sin_addr.s_addr 에 INADDR_ANY 값을 넣었다. 이는 특정 주소를 넣으면 특정 클라이언트만 접속되기 때문이다. 모든 클라이언트가 접속 할 수 있도록 하기 위해서는 INADDR_ANY 값을 넣어주면 된다. htonl 함수는 htons 함수와 마찬가지로 네트워크 바이트 오더를 적용하기 위한 것이다. htons는 short형 숫자를 반환하고, htonl은 long형 숫자를 반환한다. htonl 함수 32비트 네트워크 바이트 오더형 숫자 htonl(32비트 호스트 오더형 숫자) 32비트의 호스트 오더형 숫자를 네트워크 바이트 오더의 숫자로 변경한다. 인텔 CPU에서는 리틀 엔디안인 32비트 숫자 변수를 네트워크 바이트 오더인 빅 엔디안을 적용한 후 반환한다. #include uint32_t htonl(uint32_t hostlong) struct sockaddr_in 구조체에 주소 등의 옵션을 설정했으면 이것을 생성된 소켓에 적용시켜야 한다. 이때 bind 함수를 사용한다. bind 함수 성공 여부 반환 bind(소켓 디스크립터, 로컬 주소, 로컬 주소 구조체 크기) 생성된 소켓에 로컬 주소를 할당한다. 로컬 주소에 설정할 수 있는 옵션은 연결될 클라이언트의 주소 패밀리, IP 정보, 포트 정보가 있다. 성공하면 0을 반환, 오류가 발생하면 -1를 반환하면서 errno에 오류 번호를 넣는다. #include #include int bind(int sockfd, struct sockaddr *my_addr, socklen_t adrlen) 연결 수신 대기 if(listen(ssock, 5) \u003c 0) { perror(\"listen error : \"); exit(1); 연결 수신을 대기하도록 하려면 listen 함수를 사용한다. listen 함수에 연결하고 싶은 소켓 디스크립터와 리눅스 커널의 큐에 저장할 수 있는 최대 접속 수를 설정한다. listen 함수 성공 여부 반환 listen(소켓 디스크립터, 최대 연결할 큐의 길이) 해당 소켓에서 연결을 기다린다. 연결은 큐의 길이만큼만 가능하다. 성공하면 0, 오류가 발생하면 -1를 반환하면서 errno에 오류 번호를 넣는다. #include int listen(int s, int backlog) 연결 수신 ... if((csock # accept(ssock, (struct sockaddr *)\u0026client_addr, \u0026clen)) \u003c 0) { perror(\"accept error : \"); close(ssock); exit(1); } 소켓의 연결을 받아들이려면 accept 함수를 사용한다. accept 함수는 소켓 디스크립터를 이용해 연결 요청을 받아들인다. 연결 요청이 없는 경우에 accept 함수를 사용하면 연결 요청이 들어올 때까지 대기 상태에서 계속 연결 요청 여부를 확인하게 된다. accept 함수 성공한 소켓 디스크립터 accept(소켓 디스크립터, 접속한 상대편 연결 정보, 연결 정보 길이) 해당 소켓에 연결 요청이 들어왔을 때 연결을 받아들인다. 연결 요청이 없는 경우에는 연결 요청이 발생할 때까지 대기 상태에서 해당 소켓을 계속 감시한다. 오류가 발생하면 -1을 반환하고 연결에 성공하면 해당 소켓 디스크립터인 음이 아닌 정수를 반환한다. #include #include int accept(int s, struct sockaddr *addr, socklen_t *addrlen) 통신(읽기/쓰기) if(write(csock, buf, MAXBUF) \u003c# 0) perror(\"write error : \"); 데이터를 전송하려면 write 함수를 사용한다. write 함수 성공 시 쓰여진 데이터 길이 write(파일 디스크립터, 전송할 버퍼, 전송할 데이터 길이) 버퍼에서 데이터를 읽어서 파일 디스크립터에 인수로 주어진 크기만큼 쓴다. 쓰기게 성공하면 쓰기에 성공한 길이를 반환하고 오류가 발생하면 -1을 반환하면서 errno에 오류 번호를 넣는다. #include ssize_t write(int fd, const void *buf, size_t count) UDP 서버/클라이언트 프로그래밍 다중 접속 처리 서버 구현 RAW 소켓을 이용한 패킷 제어 참고 문서 http://kldp.org/Translations/html/Socket_Programming-KLDP/Socket_Programming-KLDP.html http://www.joinc.co.kr/modules/moniwiki/wiki.php/article/socket_layer http://forum.falinux.com/zbxe/?mid#network_programming\u0026document_srl#447826\u0026listStyle#\u0026cpage# 참고 문헌 백창우, 최영호, 조경민, 윤경훈, 윤상배. 『TCP/IP 소켓 프로그래밍』, 한빛미디어, 2005. ","wordCount":"1203","inLanguage":"en","datePublished":"2012-02-01T09:00:00+09:00","dateModified":"2012-02-01T09:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://seop.github.io/post/c-network/"},"publisher":{"@type":"Organization","name":"io.github.seop","logo":{"@type":"ImageObject","url":"https://seop.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://seop.github.io accesskey=h title="io.github.seop (Alt + H)">io.github.seop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://seop.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://seop.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://seop.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>TCP 서버/클라이언트 프로그래밍</h1><div class=post-meta><span title='2012-02-01 09:00:00 +0900 KST'>2012-02-01</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#클라이언트-프로그램>클라이언트 프로그램</a></li><li><a href=#소켓-생성>소켓 생성</a></li><li><a href=#서버의-인터넷-주소-설정>서버의 인터넷 주소 설정</a></li><li><a href=#연결-요청>연결 요청</a></li><li><a href=#통신읽기쓰기>통신(읽기/쓰기)</a></li><li><a href=#연결-종료>연결 종료</a></li><li><a href=#서버-프로그램>서버 프로그램</a></li><li><a href=#소켓-생성-1>소켓 생성</a></li><li><a href=#인터넷-주소-부여>인터넷 주소 부여</a></li><li><a href=#연결-수신-대기>연결 수신 대기</a></li><li><a href=#연결-수신>연결 수신</a></li><li><a href=#통신읽기쓰기-1>통신(읽기/쓰기)</a></li><li><a href=#udp-서버클라이언트-프로그래밍>UDP 서버/클라이언트 프로그래밍</a></li><li><a href=#다중-접속-처리-서버-구현>다중 접속 처리 서버 구현</a></li><li><a href=#raw-소켓을-이용한-패킷-제어>RAW 소켓을 이용한 패킷 제어</a></li><li><a href=#참고-문서>참고 문서</a></li><li><a href=#참고-문헌>참고 문헌</a></li></ul></nav></div></details></div><div class=post-content><h2 id=클라이언트-프로그램>클라이언트 프로그램<a hidden class=anchor aria-hidden=true href=#클라이언트-프로그램>#</a></h2><p>클라이언트 프로그램은 1. 소켓 생성, 2. 서버의 인터넷 주소 설정, 3. 연결 요청, 4. 통신(읽기/쓰기), 5. 연결 종료 순서로 진행된다.</p><h2 id=소켓-생성>소켓 생성<a hidden class=anchor aria-hidden=true href=#소켓-생성>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ssock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>((ssock <span style=color:#960050;background-color:#1e0010>#</span> socket(PF_INET, SOCK_STREAN, IPPROTO_TCP)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    perror(<span style=color:#e6db74>&#34;socket error : &#34;</span>);
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>소켓을 생성한다. socket이라는 함수에 인자값을 주어 소켓 생성에 성공하면, 0보다 큰값의 디스크립션을 반환한다. 보통 3 이상의 값이 반환된다. 0은 표준입력, 1은 표준출력, 2는 표준에러로 예약되어 있다. 소켓 생성에 실패하면 음수값의 디스크립션을 반환한다.</li><li>socket 함수</li><li>소켓 지정자 socket(인자 도메인, 소켓의 형태, 프로토콜의 종류)</li><li>해당 소켓을 생성하고 소켓의 디스크립션을 반환한다. 즉, 인자 값을 받아 소켓을 생성한 후에 해당 소켓의 지정자를 반환한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> socket(<span style=color:#66d9ef>int</span> domain, <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>int</span> protocol)
</span></span></code></pre></div><ul><li>인자 도메인 (domain)</li><li>네트워크의 종류를 나타낸다. (노벨IPX, ATM, X.25, IPv6, TCP/IP 등)</li><li>네트워크의 종류에 따라 프로토콜이 다르게 구성되어 있으며, 리눅스에서는 도메인이라는 개념을 사용해 구분한다.</li><li>TCP/IP는 PF_INET 프로토콜 패밀리에 정의되어 있다. PF_INET은 주소값이다. IP주소를 사용한다.</li><li>프로토콜 패밀리는 &lt;sys/socket.h> 에서 정의한다.</li><li>로컬 소켓을 사용해 소켓을 내부 프로세스가 통신하는 용도로 사용하려면 PF_UNIX나 PF_LOCAL를 사용한다. 내부 프로세스 통신을 위해 사용할 때는 데이터 전송을 위한 파일 경로가 들어가게 된다.</li></ul><table><thead><tr><th><strong>프로토콜 패밀리</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td>PF_UNIX</td><td>유닉스 도메인 소켓</td></tr><tr><td>PF_LOCAL</td><td>PF_UNIX 소켓의 포직스 표현</td></tr><tr><td>PF_INET</td><td>인터넷 프로토콜(TCP/IP)</td></tr><tr><td>PF_IPX</td><td>노벨 IPX</td></tr><tr><td>PF_AX25</td><td>아마추어 라디오 AX.25</td></tr><tr><td>PF_APPLETALK</td><td>애플토크 DDP</td></tr><tr><td>PF_INET6</td><td>IPv6 프로토콜</td></tr><tr><td>PF_ROSE</td><td>아마추어 라디오 X.25 PLP</td></tr><tr><td>PF_X25</td><td>X.25 프로젝트를 위해 예약</td></tr><tr><td>PF_IRDA</td><td>적외선(IrDA) 소켓</td></tr><tr><td>PF_NETBEUI</td><td>802.2LLC 프로젝트를 위해 예약</td></tr><tr><td>PF_LLC</td><td>리눅스 LLC</td></tr><tr><td>PF_BLUETOOTH</td><td>블루투스 소켓</td></tr></tbody></table><ul><li>소켓의 형태 (type)</li><li>소켓의 형태는 소켓의 연결 형식을 정의한다.</li><li>PF_INET에서 주로 사용하는 소켓 연결 형식에는 SOCK_STREAM, SOCK_DGRAM, SOCK_RAW가 있다.</li></ul><ol><li>SOCK_STREAM : TCP를 통해 전송되는 신뢰성 있는 연결</li><li>SOCK_DGRAM : UDP를 통해 전송되는 신뢰성 없는 연결.</li><li>SOCK_RAW : 헤더를 직접 만들어서 사용해야 하는 연결 형식. SOCK_STREAM, SOCK_DGRAM의 헤더는 운영체제에서 자동으로 만들어준다.</li></ol><ul><li>프로토콜의 종류 (protocol)</li><li>소켓에서 사용될 프로토콜을 지정한다.</li></ul><table><thead><tr><th><strong>프로토콜</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td>0</td><td>도메인과 소켓의 형태에 따른 기본 프로토콜이 자동 결정된다</td></tr><tr><td>IPPROTO_IP</td><td></td></tr><tr><td>IPPROTO_TCP</td><td>TCP 프로토콜 사용</td></tr><tr><td>IPPROTO_UDP</td><td>UDP 프로토콜 사용</td></tr><tr><td>IPPROTO_RAW</td><td></td></tr><tr><td>IPPROTO_ICMP</td><td></td></tr><tr><td>IPPROTO_ICMPV6</td><td></td></tr></tbody></table><h2 id=서버의-인터넷-주소-설정>서버의 인터넷 주소 설정<a hidden class=anchor aria-hidden=true href=#서버의-인터넷-주소-설정>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> server_addr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>memset(<span style=color:#f92672>&amp;</span>server_addr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(server_addr));
</span></span><span style=display:flex><span>server_addr.sin_family <span style=color:#960050;background-color:#1e0010>#</span> AF_INET; <span style=color:#75715e>/* # PF_INET */</span>
</span></span><span style=display:flex><span>server_addr.sin_addr.s_addr <span style=color:#960050;background-color:#1e0010>#</span> inet_addr(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>);
</span></span><span style=display:flex><span>server_addr.sin_port <span style=color:#960050;background-color:#1e0010>#</span> htons(<span style=color:#ae81ff>2217</span>);
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><ul><li>접속할 서버의 주소를 설정한다. 프로토콜 패밀리와 IP 주소, Port 주소를 각각 정해준다. 네트워크 바이트 오더를 적용해야 하기 때문에 IP 주소와 Port 주소는 inet_addr(), htons() 함수를 통해서 값을 넣어주어야 한다.</li><li>sockaddr_in 구조체는 INET 인터넷 프로토콜의 TCP 헤더를 구성한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> sa_family_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>in_addr</span> {
</span></span><span style=display:flex><span>    __u32 s_addr;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define __SOCK_SIZE__ 16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> {
</span></span><span style=display:flex><span>  sa_family_t sin_family; <span style=color:#75715e>/*주소패밀리*/</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span> sin_port; <span style=color:#75715e>/*포트번호*/</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>in_addr</span> sin_addr; <span style=color:#75715e>/*IP주소*/</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> __pad[__SOCK_SIZE <span style=color:#f92672>-</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>-</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>-</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>in_addr</span>)];
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Pad to size of &#39;struct sockaddr&#39; */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>inet_addr 함수</li><li>이진 바이너리 형식의 IP 주소 inet_addr(문자 형식의 IP 주소)</li><li>문자 형식의 IP 주소를 네트워크 바이트 오더를 적용한 이진 바이너리 코드로 바꾸어 변환한다.</li><li>리틀 엔디안(Little Endian)과 빅 엔디안(Big Endian) 이라는 바이트 오더의 개념을 알아야 한다. 네트워크 프로토콜 표준에서 사용하는 바이트 오더는 빅 엔디안이다. x86 호환 아키텍처에서는 리틀 엔디안을 사용한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> inet_addr(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cp)
</span></span></code></pre></div><ul><li>htons 함수</li><li>네트워크 바이트 오더가 적용된 이진 바이너리 16비트 값 htons (16비트 변수 값)</li><li>16비트의 unsigned short형 숫자 값에 네트워크 바이트 오더를 적용한 후 반환한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint16_t</span> htons(<span style=color:#66d9ef>uint16_t</span> hostshort)
</span></span></code></pre></div><h2 id=연결-요청>연결 요청<a hidden class=anchor aria-hidden=true href=#연결-요청>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>...
</span></span><span style=display:flex><span>clen <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#66d9ef>sizeof</span>(server_addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(connect(ssock, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>server_addr, clen) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>  peror(<span style=color:#e6db74>&#34;connect error :&#34;</span>);
</span></span><span style=display:flex><span>  exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>소켓 생성이 완료되면 생성된 소켓을 이용하여 서버에 연결해야 한다. 이때 connect() 함수를 사용한다.</li><li>connect 함수</li><li>리턴 값 connect(소켓 디스크립션, 서버의 IP 주소와 포트번호, 길이)</li><li>소켓 연결을 시작한다. 생성된 소켓과 서버의 정보를 이용해서 해당 서버에 연결한 후 결과값을 리턴한다. 1이면 성공, -1이면 실패를 의미한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>connect</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>serv_addr, soclen_t addrlen);
</span></span></code></pre></div><h2 id=통신읽기쓰기>통신(읽기/쓰기)<a hidden class=anchor aria-hidden=true href=#통신읽기쓰기>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>memset(buf, <span style=color:#ae81ff>0</span>, MAXBUF);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(read(ssock, buf, MAXBUF) <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>  perror(<span style=color:#e6db74>&#34;read error :&#34;</span>);
</span></span><span style=display:flex><span>  exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>서버에서 데이터를 읽어오려면 read() 함수를 사용한다. 데이터를 수신한 후 buf에 저장한다.</li><li>read 함수</li><li>읽은 값의 길이 read(파일 디스크립터, 읽은 데이터를 저장할 버퍼, 읽을 데이터 최대 길이)</li><li>지정된 파일 디스크립터에서 데이터를 읽어서 지정된 버퍼에 데이터를 넣은 후 읽은 데이터의 길이를 반환한다. 오류가 발생하면 -1을 반환한다. 네트워크 프로그래밍에서 파일 디스크립터에 해당하는 것이 소켓 디스크립터이다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>ssize_t read(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf, size_t count)
</span></span></code></pre></div><h2 id=연결-종료>연결 종료<a hidden class=anchor aria-hidden=true href=#연결-종료>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>close(ssock);
</span></span></code></pre></div><ul><li>close 함수</li><li>성공 여부 반환 close(파일 디스크립터)</li><li>close 함수는 파일 디스크립터를 닫는다. 닫힌 파일 디스크립터는 더 이상 참조되거나 사용될 수 없다. 닫기에 성공하면 0을 반환하고 오류가 발생하면 -1을 반환한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> close(<span style=color:#66d9ef>int</span> fd)
</span></span></code></pre></div><h2 id=서버-프로그램>서버 프로그램<a hidden class=anchor aria-hidden=true href=#서버-프로그램>#</a></h2><p>서버 프로그램은 1. 소켓 생성, 2. 인터넷 주소 부여, 3. 연결 수신 대기, 4. 연결 수신, 5. 통신(읽기/쓰기), 6. 연결 수신 대기(이후 과정 반복) 순서로 진행된다.</p><h2 id=소켓-생성-1>소켓 생성<a hidden class=anchor aria-hidden=true href=#소켓-생성-1>#</a></h2><p>클라이언트 프로그램 부분과 같다.</p><h2 id=인터넷-주소-부여>인터넷 주소 부여<a hidden class=anchor aria-hidden=true href=#인터넷-주소-부여>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>...
</span></span><span style=display:flex><span>server_addr.sin_family <span style=color:#960050;background-color:#1e0010>#</span> AF_INET;
</span></span><span style=display:flex><span>server_addr.sin_addr.s_addr <span style=color:#960050;background-color:#1e0010>#</span> htonl(INADDR_ANY);
</span></span><span style=display:flex><span>server_addr.sin_port <span style=color:#960050;background-color:#1e0010>#</span> htons(<span style=color:#ae81ff>2999</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(bind(ssock, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>server_addr, <span style=color:#66d9ef>sizeof</span>(server_addr)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>  perror(<span style=color:#e6db74>&#34;bind error : &#34;</span>);
</span></span><span style=display:flex><span>  exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>server_addr.sin_addr.s_addr 에 INADDR_ANY 값을 넣었다. 이는 특정 주소를 넣으면 특정 클라이언트만 접속되기 때문이다. 모든 클라이언트가 접속 할 수 있도록 하기 위해서는 INADDR_ANY 값을 넣어주면 된다.</li><li>htonl 함수는 htons 함수와 마찬가지로 네트워크 바이트 오더를 적용하기 위한 것이다. htons는 short형 숫자를 반환하고, htonl은 long형 숫자를 반환한다.</li><li>htonl 함수</li><li>32비트 네트워크 바이트 오더형 숫자 htonl(32비트 호스트 오더형 숫자)</li><li>32비트의 호스트 오더형 숫자를 네트워크 바이트 오더의 숫자로 변경한다. 인텔 CPU에서는 리틀 엔디안인 32비트 숫자 변수를 네트워크 바이트 오더인 빅 엔디안을 적용한 후 반환한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint32_t</span> htonl(<span style=color:#66d9ef>uint32_t</span> hostlong)
</span></span></code></pre></div><ul><li>struct sockaddr_in 구조체에 주소 등의 옵션을 설정했으면 이것을 생성된 소켓에 적용시켜야 한다. 이때 bind 함수를 사용한다.</li><li>bind 함수</li><li>성공 여부 반환 bind(소켓 디스크립터, 로컬 주소, 로컬 주소 구조체 크기)</li><li>생성된 소켓에 로컬 주소를 할당한다. 로컬 주소에 설정할 수 있는 옵션은 연결될 클라이언트의 주소 패밀리, IP 정보, 포트 정보가 있다. 성공하면 0을 반환, 오류가 발생하면 -1를 반환하면서 errno에 오류 번호를 넣는다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> bind(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>my_addr, socklen_t adrlen)
</span></span></code></pre></div><h2 id=연결-수신-대기>연결 수신 대기<a hidden class=anchor aria-hidden=true href=#연결-수신-대기>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span>(listen(ssock, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>  perror(<span style=color:#e6db74>&#34;listen error : &#34;</span>);
</span></span><span style=display:flex><span>  exit(<span style=color:#ae81ff>1</span>);
</span></span></code></pre></div><ul><li>연결 수신을 대기하도록 하려면 listen 함수를 사용한다. listen 함수에 연결하고 싶은 소켓 디스크립터와 리눅스 커널의 큐에 저장할 수 있는 최대 접속 수를 설정한다.</li><li>listen 함수</li><li>성공 여부 반환 listen(소켓 디스크립터, 최대 연결할 큐의 길이)</li><li>해당 소켓에서 연결을 기다린다. 연결은 큐의 길이만큼만 가능하다. 성공하면 0, 오류가 발생하면 -1를 반환하면서 errno에 오류 번호를 넣는다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> listen(<span style=color:#66d9ef>int</span> s, <span style=color:#66d9ef>int</span> backlog)
</span></span></code></pre></div><h2 id=연결-수신>연결 수신<a hidden class=anchor aria-hidden=true href=#연결-수신>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>((csock <span style=color:#960050;background-color:#1e0010>#</span> accept(ssock, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>client_addr, <span style=color:#f92672>&amp;</span>clen)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>  perror(<span style=color:#e6db74>&#34;accept error : &#34;</span>);
</span></span><span style=display:flex><span>  close(ssock);
</span></span><span style=display:flex><span>  exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>소켓의 연결을 받아들이려면 accept 함수를 사용한다. accept 함수는 소켓 디스크립터를 이용해 연결 요청을 받아들인다. 연결 요청이 없는 경우에 accept 함수를 사용하면 연결 요청이 들어올 때까지 대기 상태에서 계속 연결 요청 여부를 확인하게 된다.</li><li>accept 함수</li><li>성공한 소켓 디스크립터 accept(소켓 디스크립터, 접속한 상대편 연결 정보, 연결 정보 길이)</li><li>해당 소켓에 연결 요청이 들어왔을 때 연결을 받아들인다. 연결 요청이 없는 경우에는 연결 요청이 발생할 때까지 대기 상태에서 해당 소켓을 계속 감시한다. 오류가 발생하면 -1을 반환하고 연결에 성공하면 해당 소켓 디스크립터인 음이 아닌 정수를 반환한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> accept(<span style=color:#66d9ef>int</span> s, <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>addr, socklen_t <span style=color:#f92672>*</span>addrlen)
</span></span></code></pre></div><h2 id=통신읽기쓰기-1>통신(읽기/쓰기)<a hidden class=anchor aria-hidden=true href=#통신읽기쓰기-1>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span>(write(csock, buf, MAXBUF) <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  perror(<span style=color:#e6db74>&#34;write error : &#34;</span>);
</span></span></code></pre></div><ul><li>데이터를 전송하려면 write 함수를 사용한다.</li><li>write 함수</li><li>성공 시 쓰여진 데이터 길이 write(파일 디스크립터, 전송할 버퍼, 전송할 데이터 길이)</li><li>버퍼에서 데이터를 읽어서 파일 디스크립터에 인수로 주어진 크기만큼 쓴다. 쓰기게 성공하면 쓰기에 성공한 길이를 반환하고 오류가 발생하면 -1을 반환하면서 errno에 오류 번호를 넣는다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>ssize_t write(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf, size_t count)
</span></span></code></pre></div><h2 id=udp-서버클라이언트-프로그래밍>UDP 서버/클라이언트 프로그래밍<a hidden class=anchor aria-hidden=true href=#udp-서버클라이언트-프로그래밍>#</a></h2><h2 id=다중-접속-처리-서버-구현>다중 접속 처리 서버 구현<a hidden class=anchor aria-hidden=true href=#다중-접속-처리-서버-구현>#</a></h2><h2 id=raw-소켓을-이용한-패킷-제어>RAW 소켓을 이용한 패킷 제어<a hidden class=anchor aria-hidden=true href=#raw-소켓을-이용한-패킷-제어>#</a></h2><h2 id=참고-문서>참고 문서<a hidden class=anchor aria-hidden=true href=#참고-문서>#</a></h2><ul><li><a href=http://kldp.org/Translations/html/Socket_Programming-KLDP/Socket_Programming-KLDP.html>http://kldp.org/Translations/html/Socket_Programming-KLDP/Socket_Programming-KLDP.html</a></li><li><a href=http://www.joinc.co.kr/modules/moniwiki/wiki.php/article/socket_layer>http://www.joinc.co.kr/modules/moniwiki/wiki.php/article/socket_layer</a></li><li><a href=http://forum.falinux.com/zbxe/?mid#network_programming&amp;document_srl#447826&amp;listStyle#&amp;cpage#>http://forum.falinux.com/zbxe/?mid#network_programming&amp;document_srl#447826&amp;listStyle#&amp;cpage#</a></li></ul><h2 id=참고-문헌>참고 문헌<a hidden class=anchor aria-hidden=true href=#참고-문헌>#</a></h2><ul><li>백창우, 최영호, 조경민, 윤경훈, 윤상배. 『TCP/IP 소켓 프로그래밍』, 한빛미디어, 2005.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://seop.github.io/tags/c/>c</a></li><li><a href=https://seop.github.io/tags/tcp/>tcp</a></li><li><a href=https://seop.github.io/tags/network/>network</a></li><li><a href=https://seop.github.io/tags/server/>server</a></li><li><a href=https://seop.github.io/tags/client/>client</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://seop.github.io>io.github.seop</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>